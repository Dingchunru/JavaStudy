# JVM 核心知识体系

## 一、JVM内存模型（运行时数据区）

JVM内存模型是JVM管理内存的核心架构，JDK 8及以后版本（移除永久代、引入元空间）的内存布局如下，所有区域均为线程共享或线程私有，这是理解GC和内存溢出的基础。

### 1. 核心内存区域划分

| 区域 | 归属 | 作用 | 溢出类型 | 详细说明 |
|------|------|------|----------|----------|
| **程序计数器** | 线程私有 | 记录当前线程执行的字节码行号，唯一不会OOM的区域 | 无 | 每个线程独立存储，执行Java方法时记录字节码地址，执行Native方法时值为空，是线程切换后能恢复执行的关键 |
| **虚拟机栈** | 线程私有 | 存储方法调用的栈帧（局部变量表、操作数栈、动态链接、方法出口等），栈深度有限 | StackOverflowError<br>OutOfMemoryError | 每个方法调用创建一个栈帧，栈帧大小在编译期确定；<br>-Xss参数设置栈大小，栈深度不足时抛StackOverflowError；<br>栈内存无法扩展时抛OOM |
| **本地方法栈** | 线程私有 | 为Native方法（如JNI调用）提供栈空间，服务于Native方法 | StackOverflowError<br>OutOfMemoryError | 与虚拟机栈类似，但服务于Native方法，由C/C++实现，同样受-Xss参数影响 |
| **堆（Heap）** | 线程共享 | 存储对象实例和数组，GC核心区域（分新生代、老年代） | OutOfMemoryError: Java heap space | JVM中最大的内存区域，通过-Xms（初始堆大小）和-Xmx（最大堆大小）参数控制；<br>所有对象实例和数组都在堆上分配内存 |
| **方法区（元空间）** | 线程共享 | 存储类元信息、运行时常量池、静态变量、即时编译器编译后的代码等（JDK8后元空间直接使用本地内存） | OutOfMemoryError: Metaspace | JDK7及以前称为永久代（PermGen）；<br>JDK8后改为元空间（Metaspace），使用本地内存，通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize控制 |
| **直接内存（堆外内存）** | 线程共享 | NIO使用的堆外内存，不受JVM堆大小限制，但受物理内存限制 | OutOfMemoryError: Direct buffer memory | 通过ByteBuffer.allocateDirect()分配，性能高（减少一次拷贝），但分配和回收成本较高；<br>受-XX:MaxDirectMemorySize参数限制 |

### 2. 堆的细分结构（GC核心区域）

堆是GC最主要的操作区域，默认按"新生代:老年代 = 1:2"的比例划分：

#### **新生代（Young Generation）**
负责存放新创建的对象，生命周期较短，GC频繁。

| 区域 | 比例 | 作用 | GC触发条件 |
|------|------|------|------------|
| **Eden区** | 80% | 新对象优先分配到这里 | Eden区空间满时触发Minor GC（轻量级GC，使用复制算法） |
| **Survivor0（From区）** | 10% | 存放Minor GC后存活的对象 | 与Survivor1配合，交替作为复制目标区 |
| **Survivor1（To区）** | 10% | 同上 | 与Survivor0配合，交替作为复制目标区 |

**新生代GC流程（复制算法）：**
1. 新对象分配在Eden区
2. Eden区满时触发Minor GC
3. 将Eden区和当前使用的Survivor区中存活的对象复制到另一个空的Survivor区
4. 清空Eden区和原Survivor区
5. 对象每在Survivor区"熬过"一次Minor GC，年龄+1
6. 当对象年龄达到阈值（默认15）时，晋升到老年代

#### **老年代（Old Generation）**
存放生命周期长的对象，GC频率较低但耗时较长。

| 特点 | 说明 |
|------|------|
| **存储对象** | 大对象直接进入老年代、长期存活的对象、Survivor区放不下的对象 |
| **GC算法** | 标记-清除或标记-整理算法 |
| **GC触发** | 老年代空间不足时触发Major GC/Full GC |
| **GC特点** | STW时间较长，对应用性能影响大 |

**对象晋升老年代的条件：**
1. 对象年龄达到阈值（-XX:MaxTenuringThreshold，默认15）
2. 大对象直接进入老年代（-XX:PretenureSizeThreshold控制）
3. Survivor区中相同年龄的对象大小总和超过Survivor空间的一半
4. Minor GC后Survivor区放不下的对象

## 二、垃圾回收（Garbage Collection）机制

### 1. 垃圾判定算法

#### **引用计数法（早期算法）**
- **原理**：给每个对象添加引用计数器，被引用时+1，引用失效时-1
- **优点**：实现简单，判定效率高
- **缺点**：无法解决循环引用问题（A引用B，B引用A，但无外部引用）
- **现状**：主流JVM均未采用此算法

#### **可达性分析算法（JVM采用）**
- **原理**：以"GC Roots"为起点，通过引用链向下搜索，形成"引用链"，不在链上的对象判定为垃圾
- **GC Roots包括**：
  1. 虚拟机栈中引用的对象
  2. 方法区中静态属性引用的对象
  3. 方法区中常量引用的对象
  4. 本地方法栈中Native方法引用的对象
  5. JVM内部引用（如基本类型对应的Class对象、常驻异常对象等）
  6. 同步锁持有的对象
  7. JMXBean、JVMTI等回调注册的对象

### 2. 垃圾回收算法

| 算法 | 核心逻辑 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| **复制算法** | 将内存分为两块，每次只使用一块，GC时将存活对象复制到另一块，清空原块 | 实现简单、运行高效、无内存碎片 | 内存利用率仅50%、存活对象多时效率低 | 新生代（Eden/Survivor区） |
| **标记-清除算法** | 先标记所有需要回收的对象，标记完成后统一回收所有被标记的对象 | 不需要额外空间、实现简单 | 产生内存碎片、标记和清除效率都不高 | 老年代（早期GC收集器） |
| **标记-整理算法** | 标记过程与标记-清除相同，但后续将存活对象向内存一端移动，然后清理边界外的内存 | 无内存碎片、内存利用率高 | 移动对象成本高、需要暂停用户线程 | 老年代（现代GC收集器） |
| **分代收集算法** | 根据对象存活周期将堆分为新生代和老年代，针对不同代采用不同的回收算法 | 结合多种算法优点、整体性能最优 | 实现复杂、需要维护代际关系 | 现代JVM主流算法 |
| **G1算法** | 将堆划分为多个Region，建立可预测的停顿时间模型，优先回收价值最大的Region | 可预测停顿时间、空间整合好、大堆高效 | 算法复杂、需要更多内存维护数据结构 | 大内存、低延迟场景 |

### 3. 垃圾收集器（算法的具体实现）

#### **新生代收集器**

| 收集器 | 算法 | 线程 | 特点 | 适用场景 |
|--------|------|------|------|----------|
| **Serial** | 复制算法 | 单线程 | STW时间较长，简单高效 | 客户端应用、单核CPU |
| **ParNew** | 复制算法 | 多线程 | Serial的多线程版本，与CMS配合 | 服务端应用、多核CPU |
| **Parallel Scavenge** | 复制算法 | 多线程 | 吞吐量优先，可自适应调整 | 后台计算、注重吞吐量 |

#### **老年代收集器**

| 收集器 | 算法 | 线程 | 特点 | 适用场景 |
|--------|------|------|------|----------|
| **Serial Old** | 标记-整理 | 单线程 | Serial的老年代版本 | 客户端应用、CMS后备 |
| **Parallel Old** | 标记-整理 | 多线程 | Parallel Scavenge的老年代版本 | 吞吐量优先场景 |
| **CMS** | 标记-清除 | 并发 | 低延迟、并发收集，有内存碎片 | 响应时间敏感的应用 |

#### **全堆收集器**

| 收集器 | 算法 | 特点 | 适用场景 |
|--------|------|------|----------|
| **G1** | 标记-整理+复制 | 可预测停顿时间、分区回收、高吞吐 | JDK9+默认收集器，大内存应用 |
| **ZGC** | 染色指针 | 亚毫秒级停顿、大堆友好 | JDK11+，超大堆、极致低延迟 |
| **Shenandoah** | 转发指针 | 低停顿、并发整理 | JDK12+，关注响应时间 |

### 4. GC触发条件与类型

| GC类型 | 触发条件 | 影响范围 | 特点 |
|--------|----------|----------|------|
| **Minor GC** | Eden区空间不足 | 新生代 | 频繁、速度快、使用复制算法 |
| **Major GC** | 老年代空间不足 | 老年代 | 较慢、STW时间长 |
| **Full GC** | 1. 调用System.gc()<br>2. 老年代空间不足<br>3. 方法区空间不足<br>4. Minor GC后进入老年代的对象大小 > 老年代剩余空间 | 整个堆和方法区 | 最慢、STW时间最长、应尽量避免 |

## 三、类加载机制

JVM通过"类加载器"将.class文件（字节码）加载到内存，并转换为Class对象，整个过程分为5个阶段，核心是"双亲委派模型"。

### 1. 类加载的5个阶段

| 阶段 | 作用 | 详细说明 |
|------|------|----------|
| **加载（Loading）** | 读取.class文件到内存，生成Class对象（存方法区），通过类全限定名定位文件 | 1. 通过全限定名获取二进制字节流<br>2. 将字节流转化为方法区的运行时数据结构<br>3. 在堆中生成Class对象，作为方法区数据的访问入口 |
| **验证（Verification）** | 校验字节码合法性（如格式、语义、安全性），防止恶意字节码 | 1. 文件格式验证（魔数、版本等）<br>2. 元数据验证（继承、实现等）<br>3. 字节码验证（跳转、类型转换等）<br>4. 符号引用验证（解析阶段前） |
| **准备（Preparation）** | 为类静态变量分配内存并设置默认值（如int默认0，引用默认null） | 1. 为类变量分配内存（方法区）<br>2. 设置默认零值<br>注意：final static常量在编译期确定，准备阶段直接赋值 |
| **解析（Resolution）** | 将符号引用（如类名、方法名）转换为直接引用（内存地址） | 1. 类或接口解析<br>2. 字段解析<br>3. 类方法解析<br>4. 接口方法解析<br>解析可能在初始化之后才执行（动态绑定） |
| **初始化（Initialization）** | 执行静态代码块、赋值静态变量（执行`<clinit>()`方法） | 1. 执行类构造器`<clinit>()`方法<br>2. 父类先于子类初始化<br>3. 接口初始化不要求父接口先初始化<br>4. 多线程环境下加锁同步 |

### 2. 双亲委派模型（核心设计）

**核心规则**：类加载器加载类时，先委托父类加载器加载，父类加载失败才自己加载。

**类加载器层级（从父到子）：**
1. **启动类加载器（Bootstrap ClassLoader）**
   - C++实现，JVM一部分
   - 加载`JAVA_HOME/lib`目录下的核心类库
   - 不继承java.lang.ClassLoader

2. **扩展类加载器（Extension ClassLoader）**
   - Java实现，sun.misc.Launcher$ExtClassLoader
   - 加载`JAVA_HOME/lib/ext`目录下的扩展类库

3. **应用程序类加载器（Application ClassLoader）**
   - Java实现，sun.misc.Launcher$AppClassLoader
   - 加载用户类路径（classpath）下的类
   - 默认的类加载器

4. **自定义类加载器**
   - 用户继承ClassLoader实现
   - 可打破双亲委派（如Tomcat、OSGi等框架）

**双亲委派流程：**
```
自定义加载器 → 应用程序加载器 → 扩展类加载器 → 启动类加载器
      ↓               ↓               ↓               ↓
   加载类 → 委托父类 → 委托父类 → 委托父类 → 尝试加载
      ↑               ↑               ↑               ↑
父类失败 ← 父类失败 ← 父类失败 ← 无法加载 ← 加载成功
```

**优势**：
1. 避免类重复加载，保证类的唯一性
2. 保护核心API不被篡改（如java.lang.Object）
3. 实现类的隔离性（如Web容器中的不同应用）

**打破双亲委派的场景**：
1. JDBC SPI机制（ServiceLoader）
2. Tomcat Web应用隔离
3. OSGi模块化热部署
4. 热加载、热部署需求

### 3. 类卸载条件

类可以被卸载的条件（需同时满足）：
1. 该类所有的实例都已被GC回收
2. 该类的Class对象没有被任何地方引用
3. 加载该类的ClassLoader实例已被GC回收

**注意**：
- 核心类（如java.lang.String）永远不会被卸载
- 自定义类可能因类加载器泄漏导致元空间溢出
- Tomcat等容器需要特别注意类加载器管理

## 四、JVM性能监控与调优工具

### 1. 命令行工具集

| 工具 | 作用 | 常用命令 |
|------|------|----------|
| **jps** | 查看Java进程 | `jps -l` 显示主类全名<br>`jps -v` 显示JVM参数 |
| **jstat** | JVM统计信息监控 | `jstat -gc <pid> 1000 10`<br>`jstat -gccapacity <pid>` |
| **jstack** | 线程堆栈分析 | `jstack <pid> > thread.txt`<br>`jstack -l <pid>` 显示锁信息 |
| **jmap** | 内存映射与分析 | `jmap -heap <pid>` 堆信息<br>`jmap -histo <pid>` 对象直方图<br>`jmap -dump <pid>` 堆转储 |
| **jinfo** | 查看和修改JVM参数 | `jinfo <pid>` 查看所有参数<br>`jinfo -flag <name> <pid>` 查看特定参数 |

### 2. jstat详解：JVM统计信息监控

**核心作用**：实时监控JVM内存（堆/元空间）、GC次数/耗时、类加载等指标

**基本格式**：
```bash
jstat -<选项> <进程ID> <采样间隔(ms)> <采样次数>
```

**常用选项**：
- `-gc`：GC堆统计（容量、使用量、GC次数/时间）
- `-gccapacity`：堆各区域容量统计
- `-gcutil`：GC使用率百分比（更直观）
- `-gccause`：GC统计和原因
- `-class`：类加载/卸载统计
- `-compiler`：JIT编译统计

**输出列解读（以-gcutil为例）：**
```
S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
0.00  99.84  63.23  42.15  94.12  91.24   2180   65.021    12    3.104   68.125
```
- **S0/S1**：Survivor0/1区使用率（%）
- **E**：Eden区使用率（%）
- **O**：老年代使用率（%）
- **M**：元空间使用率（%）
- **CCS**：压缩类空间使用率（%）
- **YGC/YGCT**：Young GC次数/总耗时（秒）
- **FGC/FGCT**：Full GC次数/总耗时（秒）
- **GCT**：总GC耗时（秒）

### 3. jstack详解：线程堆栈分析

**核心作用**：导出JVM线程的堆栈信息，用于排查死锁、线程阻塞、CPU飙高等问题

**基本命令**：
```bash
jstack <进程ID> > thread_dump.txt  # 导出到文件
jstack -l <进程ID>                 # 显示锁信息
```

**线程状态说明**：
| 状态 | 说明 | 常见场景 |
|------|------|----------|
| **RUNNABLE** | 运行中（可能在执行代码或等待IO） | 正常执行、等待IO |
| **BLOCKED** | 等待获取锁（如synchronized） | 同步代码块竞争 |
| **WAITING** | 无超时等待 | Object.wait()、LockSupport.park() |
| **TIMED_WAITING** | 有超时等待 | Thread.sleep()、Object.wait(timeout) |
| **TERMINATED** | 线程已终止 | 执行完毕或异常退出 |

**关键分析场景**：

1. **死锁排查**：
   ```bash
   jstack <pid> | grep -A 10 "deadlock"
   ```
   jstack会直接标记"Found one Java-level deadlock"，并列出死锁线程的锁持有情况。

2. **CPU过高排查**：
   ```bash
   # 1. 找到高CPU进程
   top
   
   # 2. 找到高CPU线程（十进制）
   top -Hp <pid>
   
   # 3. 将线程ID转为十六进制
   printf "%x\n" <thread_id>
   
   # 4. 在jstack输出中查找该线程
   jstack <pid> | grep -A 20 <hex_thread_id>
   ```

3. **线程阻塞分析**：
   - 查看BLOCKED状态的线程，分析锁竞争
   - 查看WAITING/TIMED_WAITING状态的线程，分析等待条件

### 4. 可视化监控工具

| 工具 | 类型 | 特点 | 适用场景 |
|------|------|------|----------|
| **JConsole** | JDK内置 | 简单易用，基础监控 | 开发环境、简单监控 |
| **VisualVM** | JDK内置 | 功能全面，插件扩展 | 开发测试、性能分析 |
| **JMC（Java Mission Control）** | JDK商业 | 专业强大，飞行记录器 | 生产环境、深度分析 |
| **Arthas** | 阿里开源 | 在线诊断，无需重启 | 生产环境、实时诊断 |
| **Prometheus + Grafana** | 开源监控 | 时序数据，可视化展示 | 生产环境、集群监控 |

## 五、内存溢出分析与解决

内存溢出（Memory Overflow）是Java开发中常见的问题，指程序在申请内存时，没有足够的内存空间供其使用。

### 1. 堆溢出（OutOfMemoryError: Java heap space）

**原因**：
1. 内存泄漏（对象无法被GC回收）
2. 堆大小设置不合理（-Xmx太小）
3. 大量大对象创建（如大数组）
4. 频繁创建对象，GC来不及回收

**排查步骤**：
1. 使用`jmap -histo:live <pid>`查看对象分布
2. 使用`jmap -dump:format=b,file=heap.bin <pid>`导出堆转储
3. 使用MAT（Memory Analyzer Tool）分析堆转储文件
4. 查找疑似内存泄漏的类

**解决方案**：
1. 增加堆大小：`-Xmx4g -Xms4g`
2. 优化代码，避免内存泄漏
3. 使用对象池技术
4. 合理设置GC参数

### 2. 元空间溢出（OutOfMemoryError: Metaspace）

**原因**：
1. 大量动态类生成（如CGlib、ASM）
2. 热部署频繁
3. 元空间大小设置不合理

**解决方案**：
```bash
# 调整元空间大小
-XX:MetaspaceSize=256m
-XX:MaxMetaspaceSize=512m

# 启用类卸载
-XX:+ClassUnloading
-XX:+ClassUnloadingWithConcurrentMark
```

### 3. 栈溢出（StackOverflowError）

**原因**：
1. 无限递归调用
2. 栈深度过大
3. 栈大小设置过小

**解决方案**：
1. 检查递归终止条件
2. 增加栈大小：`-Xss2m`
3. 将递归改为循环

### 4. 直接内存溢出（OutOfMemoryError: Direct buffer memory）

**原因**：
1. 大量使用DirectByteBuffer
2. 直接内存回收不及时

**解决方案**：
1. 增加直接内存大小：`-XX:MaxDirectMemorySize=512m`
2. 合理使用DirectByteBuffer，及时清理
3. 使用池化技术

### 5. GC Overhead Limit Exceeded

**原因**：GC花费超过98%的时间，但回收的内存少于2%

**解决方案**：
1. 优化代码，减少对象创建
2. 调整GC策略
3. 增加堆大小
4. 禁用该限制（不推荐）：`-XX:-UseGCOverheadLimit`

## 六、JVM参数调优

### 1. 堆内存参数

| 参数 | 说明 | 推荐值 |
|------|------|--------|
| `-Xms` | 初始堆大小 | 与-Xmx相同，避免扩容 |
| `-Xmx` | 最大堆大小 | 物理内存的1/4~1/2 |
| `-Xmn` | 新生代大小 | 一般为堆的1/3~1/2 |
| `-XX:NewRatio` | 新生代:老年代比例 | 默认2（即1:2） |
| `-XX:SurvivorRatio` | Eden:Survivor比例 | 默认8（即8:1:1） |

### 2. GC相关参数

| 参数 | 说明 | 推荐值 |
|------|------|--------|
| `-XX:+UseG1GC` | 使用G1收集器 | JDK9+默认 |
| `-XX:MaxGCPauseMillis` | 最大GC停顿时间 | 200（毫秒） |
| `-XX:ParallelGCThreads` | 并行GC线程数 | CPU核心数 |
| `-XX:ConcGCThreads` | 并发GC线程数 | 一般为并行线程的1/4 |
| `-XX:+PrintGCDetails` | 打印GC详细信息 | 调试时启用 |
| `-XX:+PrintGCDateStamps` | 打印GC时间戳 | 生产环境启用 |

### 3. 性能监控参数

| 参数 | 说明 |
|------|------|
| `-XX:+HeapDumpOnOutOfMemoryError` | OOM时生成堆转储 |
| `-XX:HeapDumpPath=<path>` | 堆转储文件路径 |
| `-XX:ErrorFile=<path>` | 错误日志文件路径 |
| `-XX:+PrintCommandLineFlags` | 打印JVM参数 |

### 4. 调优原则

1. **初始值和最大值保持一致**：避免堆动态调整带来的性能开销
2. **新生代不宜过大或过小**：过大会导致YGC时间过长，过小会导致频繁YGC
3. **根据应用特点选择GC器**：
   - 吞吐量优先：Parallel Scavenge + Parallel Old
   - 低延迟优先：G1或ZGC
4. **监控GC日志**：定期分析GC频率和耗时
5. **循序渐进**：每次只调整1-2个参数，观察效果后再调整

---

## 总结

JVM是Java程序的运行基础，深入理解其内存模型、垃圾回收机制、类加载原理以及性能监控工具，对于开发高性能、高可用的Java应用至关重要。在实际工作中，应根据应用特点合理配置JVM参数，建立完善的监控体系，及时发现并解决性能问题。
