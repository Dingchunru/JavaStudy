Java并发编程：生产者消费者模型与核心同步机制详解

一、核心概念前置理解
    1. JMM（Java内存模型）
        JMM是Java虚拟机定义的内存访问规则，解决多线程下内存  可见性、原子性、有序性  问题：
        - 主内存：所有线程共享的内存区域，存储对象的实际数据；
        - 工作内存：每个线程独有的内存区域，拷贝主内存的变量副本进行操作；
        - 核心问题：线程修改工作内存的变量后，何时同步到主内存（可见性）；多线程操作时是否保证指令不重排（有序性）；操作是否不可分割（原子性）。
    2. volatile
        volatile是轻量级同步关键字，仅保证可见性和有序性，不保证原子性：
        - 可见性：线程修改volatile变量后，立即同步到主内存；其他线程读取时，强制从主内存加载，而非工作内存；
        - 有序性：禁止指令重排（通过内存屏障实现），典型场景如单例模式的双重检查锁定（DCL）；
        - 局限性：无法解决复合操作的原子性（如`i++`，包含读-改-写三步）。

    3. CAS（Compare-And-Swap）
        CAS是无锁同步的核心思想，基于硬件指令实现，包含三个操作数：
        - 内存值V：要修改的变量在主内存中的值；
        - 预期值A：线程工作内存中保存的变量副本；
        - 新值B：要更新的目标值；
        - 逻辑：若V == A，则将V更新为B；否则不操作，返回当前V。
        - 特点：非阻塞、自旋（失败后重试），但存在ABA问题（可通过版本号解决，如AtomicStampedReference）。

    4. 线程池
        线程池是管理线程的容器，避免频繁创建/销毁线程的开销，核心参数（ThreadPoolExecutor）：
        - corePoolSize：核心线程数（常驻线程）；
        - maximumPoolSize：最大线程数；
        - keepAliveTime：非核心线程空闲超时时间；
        - workQueue：任务队列（如ArrayBlockingQueue、LinkedBlockingQueue）；
        - 核心优势：复用线程、控制并发数、任务缓存、线程管理。

    5. 锁的核心分类
        | 类型         | 核心特征                     | 典型实现               |
        |--------------|------------------------------|------------------------|
        | 悲观锁       | 假设一定会有竞争，先加锁再执行 | synchronized、ReentrantLock |
        | 乐观锁       | 假设无竞争，CAS重试           | AtomicInteger等原子类  |
        | 可重入锁     | 同一线程可重复获取同一把锁   | synchronized、ReentrantLock |
        | 独占锁       | 同一时间仅一个线程持有        | synchronized、ReentrantLock |
        | 公平锁/非公平锁 | 按等待顺序获取/抢占式获取     | ReentrantLock（可配置）、synchronized（非公平） |

二、生产者消费者模型实现（多版本）
    生产者消费者模型是典型的并发场景：生产者生产数据放入缓冲区，消费者从缓冲区取数据消费，核心解决缓冲区空/满的同步问题。
三、synchronized与ReentrantLock深度对比
    | 维度                | synchronized                          | ReentrantLock                          |
    |---------------------|---------------------------------------|----------------------------------------|
    |       锁的实现        | JVM层面的内置锁（监视器锁），通过monitorenter/monitorexit指令实现 | JDK层面的显式锁，基于AQS（抽象队列同步器）实现 |
    |       锁的类型        | 非公平锁（默认），无法修改            | 可配置公平/非公平锁（构造函数参数）|
    |       获取/释放方式   | 自动获取/释放（代码块结束/异常时自动释放） | 手动获取（lock()）/释放（unlock()），必须在finally中释放 |
    |       可中断性        | 不可中断（等待锁的线程无法被中断）| 支持可中断（lockInterruptibly()）|
    |       超时获取锁      | 不支持                                | 支持（tryLock(long time, TimeUnit unit)） |
    |       条件变量（Condition） | 仅有一个条件队列（wait/notify），唤醒所有等待线程 | 可创建多个Condition，精准唤醒指定线程 |
    |       锁的状态查询    | 无法查询（如是否持有锁、队列长度）| 支持（isLocked()、isFair()、getQueueLength()等） |
    |       性能            | JDK1.6后优化（偏向锁、轻量级锁、重量级锁），低竞争下与ReentrantLock接近 | 高竞争下性能更优，可灵活控制 |
    |       可重入性        | 支持可重入（同一线程可多次获取）| 支持可重入（默认最大重入次数为Integer.MAX_VALUE） |
    |       使用场景        | 简单同步场景（如方法/代码块同步）| 复杂同步场景（如超时等待、中断、精准唤醒） |



